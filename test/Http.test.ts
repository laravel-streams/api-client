import { params, skip, suite, test } from '@testdeck/mocha';
import { TestCase } from './TestCase';
import { Http, HTTPError } from '../src';

import f from 'faker';
import { expect } from 'chai';

@suite('Http')
export class HttpTest extends TestCase {
    protected get http(): Http {return this.getHttp();}

    @test('resolve HTTP instance')
    async resolveHttpInstance() {
        const http = this.getHttp();
        http.should.be.instanceof(Http);
    }

    @test('getting nonexistant stream should result in HTTPError')
    async gettingNonexistantStreamShouldResultInHttperror() {
        const http = await this.getHttp();
        try {
            const stream = await http.getStream('users2');
        } catch (e) {
            e.should.be.instanceof(HTTPError);
        }
    }

    @skip
    @test('postStream')
    async postStreamTest() {
        this.fs.project.deleteStream('clients');
        const http             = await this.getHttp();
        const { data: stream } = await http.postStream(this.getStreamDefinition('clients'));

        this.fs.project.hasStream('clients').should.eq(true);

        stream.should.have.property('data');
        stream.data.should.have.property('id');
        stream.should.have.property('links');
        stream.should.have.property('meta');
        stream.should.have.property('errors');

        const response = await http.deleteStream(stream.data.id);
        response.data.should.eq('');
        this.fs.project.hasStream('clients').should.eq(false);
    }

    @test('getStream')
    @params({ name: 'clients' }, 'get stream "clients"')
    @params({ name: 'posts' }, 'get stream "posts"')
    async getStreamTest({ name }: { name: string }) {
        this.fs.fixtures.copyStream(name, this.fs.project);
        const stream = await this.http.getStream(name);
        stream.should.have.property('data');
        this.fs.project.deleteStream(name);
    }

    @test('patchStream')
    async patchStreamTest() {
        this.fs.fixtures.copyStream('posts', this.fs.project);
        let res = await this.http.getStream('posts');
        res.should.have.property('data');
        res.data.data.description = 'foobarfoofoo';
        res                       = await this.http.patchStream('posts', res.data.data);
        res.should.have.property('data');
        res.data.data.description.should.equal('foobarfoofoo');
        this.fs.project.getStream('posts').get('description').should.eq('foobarfoofoo');
        this.fs.project.deleteStream('posts');
    }

    @test('putStream')
    async putStreamTest() {
        this.fs.project.deleteStream('foobars');
        await this.http.putStream('foobars', this.getStreamDefinition('foobars'));
        this.fs.project.hasStream('foobars').should.eq(true);
    }

    @test('deleteStream')
    async deleteStreamTest() {
        this.fs.fixtures.copyStream('posts', this.fs.project);
        let response = await this.http.deleteStream('posts');
        this.assertResOk(response);
        this.fs.project.hasStream('posts').should.eq(false);
    }

    @test('getEntries')
    async getEntriesTest() {
        this.fs.fixtures.copyStream('posts', this.fs.project);
        let response = await this.http.getEntries('posts');
        this.assertResOk(response);
        response.data.data.length.should.eq(20);
        let entries      = response.data.data;
        let localEntries = this.fs.project.getStreamEntries('posts');
        let spaces                                 = entries.map(entry => entry.space);
        for ( const entry of localEntries ) {
            spaces.includes(entry.space).should.eq(true);
        }
        this.fs.project.deleteStream('posts');
    }

    @test('getEntry')
    async getEntryTest() {
        this.fs.fixtures.copyStream('clients', this.fs.project);
        const stream      = this.fs.project.getStream('clients');
        const fentries    = this.fs.project.generateFakeStreamEntries('clients', 20);
        const fentry: any = fentries[ '0' ];
        const http        = await this.getHttp();
        const res         = await http.getEntry('clients', '0');
        this.assertResOk(res);
        const entry = res.data.data;
        delete fentry.id // @todo still have to sort out id stuff on backend
        delete fentry.foo // @todo booleans are transformed to 0 or 1
        for ( const key of Object.keys(fentry) ) {
            entry[ key ].should.eq(fentry[ key ]);
        }
        this.fs.project.deleteStream('clients');
    }

    @test('postEntry')
    async postEntryTest() {
        this.fs.fixtures.copyStream('clients', this.fs.project);
        const http      = await this.getHttp();
        const data: any = {
            id   : 5, // @todo ids should be autogenerated
            name : f.name.firstName(),
            email: '',
            age  : 55,
        };
        data.email      = f.internet.email(data.name);
        const entry     = await http.postEntry('clients', data);
        this.assertResOk(entry);
        let entries: Record<string, { id: number, name: string, email: string, age: number }> = this.fs.project.getStreamEntries('clients');
        let found                                                                             = Object.values(entries).find(e => e.id === data.id && e.email === data.email && e.age === data.age && e.name === data.name);
        found.should.not.be.undefined;
        found.email.should.eq(data.email);
        this.fs.project.deleteStream('clients');
    }

    @test('postExistingIdEntry')
    async postExistingIdEntryTest() {
        this.fs.fixtures.copyStream('clients', this.fs.project);
        let fstream = this.fs.project.getStream('clients');
        fstream.put('5', {
            id   : 5, // @todo ids should be autogenerated
            name : 'richard',
            email: 'richard@gmail.com',
            age  : 55,
        });

        const http      = await this.getHttp();
        const data: any = {
            id   : 5, // @todo ids should be autogenerated
            name : 'robert',
            email: 'robert@gmail.com',
            age  : 55,
        };
        const entry     = await http.postEntry('clients', data);
        this.assertResOk(entry);
        let entries: Record<string, { id: number, name: string, email: string, age: number }> = this.fs.project.getStreamEntries('clients');
        let found                                                                             = Object.values(entries).find(e => e.id === data.id && e.email === data.email && e.age === data.age && e.name === data.name);
        found.should.not.be.undefined;
        found.email.should.eq(data.email);
        this.fs.project.deleteStream('clients');
    }

    @skip
    @test('postEntryWithoutId')
    async postEntryWithoutId() {
        this.fs.fixtures.copyStream('clients', this.fs.project);
        this.fs.project.deleteStreamData('clients');
        const http      = await this.getHttp();
        const data: any = {
            name : 'robert',
            email: 'robert@gmail.com',
            age  : 55,
        };
        const entry     = await http.postEntry('clients', data);
        this.assertResOk(entry);
        let entries: Record<string, { id: number, name: string, email: string, age: number }> = this.fs.project.getStreamEntries('clients');
        let found                                                                             = Object.values(entries).find(e => e.id === data.id && e.email === data.email && e.age === data.age && e.name === data.name);
        found.should.not.be.undefined;
        found.email.should.eq(data.email);
        this.fs.project.deleteStream('clients');
    }

    @test('patchEntry')
    async patchEntryTest() {
        this.fs.fixtures.copyStream('clients', this.fs.project);
        const stream      = this.fs.project.getStream('clients');
        const fentries    = this.fs.project.generateFakeStreamEntries('clients', 20);
        const fentry: any = fentries[ '0' ];
        const http        = await this.getHttp();
        // @todo HTTPError: HTTP 500 Error: The ID attribute is required.
        // const res         = await http.patchEntry('clients', '0', {email: 'test@test.com'});
        const res         = await http.patchEntry('clients', '0', {id: fentry.id, email: 'test@test.com'});
        this.assertResOk(res);
        const entries = this.fs.project.getStreamEntries('clients')
        entries["0"].email.should.eq('test@test.com')
    }

    @test('putEntry create')
    async putEntryTest() {
        this.fs.fixtures.copyStream('profiles', this.fs.project);
        let binaryNumber = Math.round(Math.random());
        let binaryNumber2 = Math.round(Math.random());
        let degrees = [];// "MD",            "PhD"        ]
        if(binaryNumber ===1 ) degrees.push('MD')
        if(binaryNumber2 ===1 ) degrees.push('PhD')
        const data = {
            "id":1,
            "role": ["md","rn"][binaryNumber],
            "degrees": degrees,
            "title":f.name.title(),
            "specialty": f.random.words(),
            "picture": f.image.imageUrl(),
            "username": 'test-user'
        }
        const res = await this.http.putEntry('profiles',"1",data);
        this.assertResOk(res)
        const entries = this.fs.project.getStreamEntries('profiles');
        entries[0].picture.should.eq(data.picture)
        this.fs.project.deleteStream('profiles')
    }

    @test('deleteEntry')
    async deleteEntryTest() {
        this.fs.fixtures.copyStream('profiles', this.fs.project);
        let binaryNumber = Math.round(Math.random());
        let binaryNumber2 = Math.round(Math.random());
        let degrees = [];// "MD",            "PhD"        ]
        if(binaryNumber ===1 ) degrees.push('MD')
        if(binaryNumber2 ===1 ) degrees.push('PhD')

        const data = {
            "id":1,
            "role": ["md","rn"][binaryNumber],
            "degrees": degrees,
            "title":f.name.title(),
            "specialty": f.random.words(),
            "picture": f.image.imageUrl(),
            "username": 'test-user'
        }
        this.fs.project.createStreamEntries('profiles',[data])
        const res = await this.http.deleteEntry('profiles', 1)
        this.assertResOk(res);
        const entries = this.fs.project.getStreamEntries('profiles');
        entries.should.be instanceof(Array)
    }

    protected assertResOk(res) {
        return expect(res.ok).eq(true);
    }
}
